
//
//  Virtual Machine
//


#ifndef VM_H
#define VM_H

#include "lexer.h"
#include "bytecode.h"
#include "value.h"


// Color codes
#define NORMAL  "\x1B[0m"
#define BOLD    "\x1B[1m"
#define RED     "\x1B[31m"
#define GREEN   "\x1B[32m"
#define YELLOW  "\x1B[33m"
#define BLUE    "\x1B[34m"
#define MAGENTA "\x1B[35m"
#define CYAN    "\x1B[36m"
#define WHITE   "\x1B[37m"


// The maximum number of functions a program can define.
#define MAX_FUNCTIONS 1024

// The maximum number of arguments that can be passed to a function.
#define MAX_ARGUMENTS 32

// The maximum number of string literals that can be
// in the source code.
#define MAX_STRING_LITERALS 1024


// A function generated by the compiler.
typedef struct {
	// A pointer to the start of the function's name in the
	// source code.
	//
	// If this is the main function (outside any function
	// definition), then this is NULL.
	char *name;

	// The length of the function's name in the source code.
	// Excludes the NULL terminator.
	int length;

	// The function's compiled bytecode.
	Bytecode bytecode;

	// The names of the arguments passed to the function.
	SourceString arguments[MAX_ARGUMENTS];

	// The number of arguments passed to the function.
	int argument_count;
} Function;


// A call frame, storing information about the functions
// currently executing.
typedef struct {
	// The function's stack pointer, indicating the start of
	// the function's stack of values.
	uint64_t *stack_ptr;

	// The instruction pointer, pointing into the function's
	// bytecode.
	uint8_t *instruction_ptr;
} CallFrame;


// The virtual machine.
//
// The VM is responsible for compiling the code initially, and then
// executing the compiled bytecode.
typedef struct {
	// A pointer to the start of the source code.
	char *source;

	// A lexer, producing a stream of tokens from the source code.
	Lexer lexer;

	// A list of functions defined during compilation.
	//
	// The main function (for all code outside of an actual function
	// definition) will be the first function in this list.
	Function functions[MAX_FUNCTIONS];

	// The number of functions that we've compiled.
	int function_count;

	// A list of string literal constants.
	String *literals[MAX_STRING_LITERALS];

	// The number of string literals in the constants list.
	int literal_count;
} VirtualMachine;


// The type of a native function.
typedef void (*NativeFunction)(
	VirtualMachine *vm,
	uint64_t *stack,
	int *stack_size);


// Create a new virtual machine with the given source code.
// Initialises the VM with default values, and doesn't compile
// anything.
VirtualMachine vm_new(char *source);

// Free any resources allocated by the VM.
void vm_free(VirtualMachine *vm);

// Compiles the source code into bytecode.
void vm_compile(VirtualMachine *vm);

// Runs the compiled bytecode.
void vm_run(VirtualMachine *vm);

// Trigger a runtime error on the virtual machine.
void vm_crash(VirtualMachine *vm, char *fmt, ...);


// Defines a new function on the virtual machine, returning
// a pointer to it.
// Performs no allocation, so the bytecode array for the
// returned function still needs to be allocated.
Function * define_bytecode_function(VirtualMachine *vm);

// Returns the index of a function with the given name and
// name length.
// Returns -1 if the function isn't found.
int find_function(
	VirtualMachine *vm,
	char *name,
	int length,
	int argument_count);

// Returns a function pointer to a library function with the
// given name and length.
// Returns NULL if the function isn't found.
NativeFunction find_native_function(
	VirtualMachine *vm,
	char *name,
	int length,
	int argument_count);

#endif
